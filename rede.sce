function rede()
    N1E1 = [0 1 1...
            1 0 1...
            0 0 1...
            0 0 1...
            0 0 1]
    N1E2 = [1 1 1...
            0 0 1...
            0 0 1...
            0 0 1...
            0 0 1]
    N1E3 = [0 1 1...
            0 0 1...
            0 0 1...
            0 0 1...
            0 0 1]
    N1E4 = [0 0 1...
            0 0 1...
            0 0 1...
            0 0 1...
            0 0 1]
    N1E5 = [0 0 1...
            0 1 1...
            0 0 1...
            0 0 1...
            0 0 1]
    N2E1 = [1 1 1...
            0 0 1...
            1 1 1...
            1 0 0...
            1 1 1]
    N3E1 = [1 1 1...
            0 0 1...
            1 1 1...
            0 0 1...
            1 1 1]
    N4E1 = [1 0 1...
            1 0 1...
            1 1 1...
            0 0 1...
            0 0 1]
    N5E1 = [1 1 1...
            1 0 0...
            1 1 1...
            0 0 1...
            1 1 1]
    N6E1 = [1 1 1...
            1 0 0...
            1 1 1...
            1 0 1...
            1 1 1]
    N7E1 = [1 1 1...
            0 0 1...
            1 1 1...
            0 0 1...
            0 0 1]
    N8E1 = [1 1 1...
            1 0 1...
            1 1 1...
            1 0 1...
            1 1 1]
    N9E1 = [1 1 1...
            1 0 1...
            1 1 1...
            0 0 1...
            1 1 1]
    alpha = 0.1
    b = 1
    yt = [0 0 1]// 0 0 1 0 0 1 0 0 1 0 0 1]
    yt = yt'
    x = [N1E1 b]
         //N1E2 b;
         //N1E3 b;
         //N1E4 b;
         //N1E5 b]
    vw1 = ones(1, 16)
    vw2 = ones(1, 16)
    vw3 = ones(1, 16)
    e = []
    for i=1:1000
        //disp(x, "x")
        z = [x zeros(x) zeros(x); zeros(x) x zeros(x); zeros(x) zeros(x) x] * [vw1'; vw2'; vw3']
        a = sigmoid(z)
        disp(a, 'a')
        erro = 2 * (a - yt).^2
        //erro2 = a(2) - yt(2)
        //erro3 = a(3) - yt(3)
        e = [e, sum(erro)]
        //e2(i) = 1/2 * erro2^2
        //e3(i) = 1/2 * erro3^2
        disp(erro, "erro")
        //disp(z, "z")
        //disp(x, "x")
        gw1 = erro(1) * dsigmoid(z(1)) * x
        gw2 = erro(2) * dsigmoid(z(2)) * x
        gw3 = erro(3) * dsigmoid(z(3)) * x
        //gb = erro * sigmoid(z)
        g = [gw1, gw2, gw3]; //disp(g, 'g')
        ng = [norm(gw1), norm(gw2), norm(gw3)]
        if norm(g)==0 break end;//disp(sum(g), 'g')
        //gw1 = gw1/ng(1)
        //gw2 = gw2/ng(2)
        //gw3 = gw3/ng(3)
        //gb = gb/ng
        //[nc, nl] = size(x)
        for i=1:size(x)(1)
            disp(vw1, "vw1")
            disp(gw1'(i, 1:$), "gradiente")
            vw1 = vw1 - alpha * gw1(i, 1:$)
            vw2 = vw2 - alpha * gw2(i, 1:$)
            vw3 = vw3 - alpha * gw3(i, 1:$)
            //b = b - gb
        end
    end
    disp(a, "a final")
    disp(i, "i")
    plot(e)
endfunction

function y=f(x)
    y = x
endfunction

function s=sigmoid(z)
    s = 1./(1 + exp(-z))
endfunction

function dy=dsigmoid(x)
    d = 0.0000001
    dy = (sigmoid(x+d) - sigmoid(x))/d
endfunction
